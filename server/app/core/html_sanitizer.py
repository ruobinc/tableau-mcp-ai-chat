"""Utilities for sanitizing HTML snippets generated by LLMs."""
from __future__ import annotations

import html
import re
from html.parser import HTMLParser
from typing import List, Tuple

_MAX_CANVAS_WIDTH = 600
_MAX_CANVAS_HEIGHT = 400
_MAX_ELEMENT_HEIGHT = 400

_PX_VALUE_RE = re.compile(r"(-?\d+(?:\.\d+)?)px", re.IGNORECASE)


def _clamp_numeric(value: str, maximum: int) -> str:
    """Clamp a numeric string representation to the provided maximum."""
    try:
        numeric = float(value)
    except (TypeError, ValueError):
        return value

    if numeric > maximum:
        # Canvas attributes expect integers. Preserve decimals otherwise.
        numeric = maximum

    # Strip trailing .0 for cleaner output.
    if numeric.is_integer():
        return str(int(numeric))
    return str(numeric)


def _clamp_px_value(value: str, maximum: int) -> str:
    """Clamp a CSS pixel value (e.g. '800px') to the given maximum."""
    match = _PX_VALUE_RE.search(value)
    if not match:
        return value

    number = float(match.group(1))
    if number <= maximum:
        return value

    clamped = f"{int(maximum)}px"
    start, end = match.span()
    return value[:start] + clamped + value[end:]


def _sanitize_style(style: str, *, is_canvas: bool) -> str:
    """Clamp width/height rules defined inside a style attribute."""
    declarations: List[str] = []
    for part in style.split(';'):
        stripped = part.strip()
        if not stripped:
            continue

        if ':' not in stripped:
            declarations.append(stripped)
            continue

        prop, value = stripped.split(':', 1)
        prop_name = prop.strip().lower()
        value_str = value.strip()

        if is_canvas and prop_name in {"width", "max-width"}:
            value_str = _clamp_px_value(value_str, _MAX_CANVAS_WIDTH)
        if prop_name in {"height", "max-height"}:
            limit = _MAX_CANVAS_HEIGHT if is_canvas else _MAX_ELEMENT_HEIGHT
            value_str = _clamp_px_value(value_str, limit)

        declarations.append(f"{prop.strip()}: {value_str}")

    return '; '.join(declarations)


def _sanitize_attributes(tag: str, attrs: List[Tuple[str, str | None]]) -> List[Tuple[str, str | None]]:
    """Sanitize attributes for a given tag."""
    sanitized: List[Tuple[str, str | None]] = []
    for name, value in attrs:
        if value is None:
            sanitized.append((name, value))
            continue

        if tag == "canvas" and name in {"width", "height"}:
            maximum = _MAX_CANVAS_WIDTH if name == "width" else _MAX_CANVAS_HEIGHT
            value = _clamp_numeric(value, maximum)

        if name == "style":
            value = _sanitize_style(value, is_canvas=(tag == "canvas"))

        sanitized.append((name, value))

    return sanitized


class _SanitizingHTMLParser(HTMLParser):
    """HTML parser that clamps problematic attributes and style rules."""

    def __init__(self) -> None:
        super().__init__(convert_charrefs=False)
        self._parts: List[str] = []

    def handle_starttag(self, tag: str, attrs: List[Tuple[str, str | None]]) -> None:
        sanitized_attrs = _sanitize_attributes(tag, attrs)
        attr_string = ''.join(
            f" {name}" if value is None else f" {name}=\"{html.escape(value, quote=True)}\""
            for name, value in sanitized_attrs
        )
        self._parts.append(f"<{tag}{attr_string}>")

    def handle_startendtag(self, tag: str, attrs: List[Tuple[str, str | None]]) -> None:
        sanitized_attrs = _sanitize_attributes(tag, attrs)
        attr_string = ''.join(
            f" {name}" if value is None else f" {name}=\"{html.escape(value, quote=True)}\""
            for name, value in sanitized_attrs
        )
        self._parts.append(f"<{tag}{attr_string} />")

    def handle_endtag(self, tag: str) -> None:
        self._parts.append(f"</{tag}>")

    def handle_data(self, data: str) -> None:
        self._parts.append(data)

    def handle_comment(self, data: str) -> None:
        self._parts.append(f"<!--{data}-->")

    def handle_decl(self, decl: str) -> None:
        self._parts.append(f"<!{decl}>")

    def handle_entityref(self, name: str) -> None:
        self._parts.append(f"&{name};")

    def handle_charref(self, name: str) -> None:
        self._parts.append(f"&#{name};")

    def get_html(self) -> str:
        return ''.join(self._parts)


def sanitize_chart_html(html_snippet: str) -> str:
    """Clamp excessive dimensions from HTML snippets.

    If parsing fails for any reason the original HTML is returned unchanged.
    """
    parser = _SanitizingHTMLParser()
    try:
        parser.feed(html_snippet)
        parser.close()
    except Exception:
        return html_snippet

    return parser.get_html()
